\documentclass[12pt,a4paper,titlepage,oneside]{scrartcl}
\newcommand{\lang}{en}
\usepackage{gaborProtocol}

\newcommand{\datum}{\today}
\newcommand{\lvaname}{Seminar aus Medizinischer Informatik}
\newcommand{\lvanr}{188.948}
\newcommand{\semester}{SS 2017}
\newcommand{\colormode}{color}
\newcommand{\dokumenttyp}{Image Encryption in Medicine}
\usepackage{xcolor}
\usepackage{amsmath}
\newcommand\todo[1]{\textcolor{red}{#1}}

\begin{document}
\maketitle
\setcounter{section}{0}
\setcounter{tocdepth}{2}
\tableofcontents
\newpage

ABSTRACT

\section{Introduction}

\todo{introduction to the general topic}
Privacy is one of the key issues of the information age.
Especially in the post-Snowden era this fact has become clear to the most individuals around the globe. 
Numerous regulations and laws \cite{EHG2015, DSG2000, ELGA2012, EuropeanParliament2016, EuropeanCourtofHumanRights2010} require it across all kinds of use cases and industries.
A well known way to achieve privacy is through encryption, which means encoding an information in such a way that only authorized parties can access it. 
Hardly any efforts on implementing encryption can be found in photography, which is a remarkable finding, keeping in mind that photographs are generally among the most private media.
This statement becomes even more astonishing considering the year, when the first patent for such a solution was registered: 1999. \cite{steinberg1999method}
To fulfill the requirements of privacy in photography it might be necessary to encrypt photographs right after they are taken.

\todo{background and motivation}
Especially in the context of medicine this is very important as health data is considered the most private data. \cite{williams2013}
Medical photographs show a patients body, they are used to document visual properties of the skin, the state of a wound or the progress of a plastic surgery. 
All of the above mentioned photographs document very private information about an individual, which is only to be seen by authorized persons.

Another important application for encryption of photographs is journalism.
Journalists are looking for possibilities to hide any traces of sensitive material on their devices, for obvious reasons.
This is called ``plausible deniability'', or to be more precise, according to the Oxford dictionary, plausible deniability is ``the possibility of denying a fact, especially a discreditable action without arousing suspicion''.\cite{OxforddictPlausibleDen}
Journalists take big risks on them when taking precarious pictures in countries with authoritarian governments, where such actions are considered as act of crime and punished with imprisonment or even death penalty \cite{Amnesty2016}.
So it could be possible that encryption would not be enough to keep the journalists safe, as a trace of encrypted images could already lead to punishments.
Encryption is a first step to achieve this level of privacy.
For this reason 150 journalists wrote an open letter to camera manufacturers, asking them to implement such a feature, in December 2016.\cite{fp2016}

\todo{description of the addressed scientific problem}
So we can state that there is a demand for digital single-lens reflex (DSLR) photo encryption feature which is not (yet) satisfied by state of the art devices.
This fact may lead physicians or journalists to take their private devices, which support encryption, for taking photographs, which is no real option for neither professional privacy nor professional image quality.

Privacy is strictly regulated by law, the most important regulations may be found in the general protected data regulation of the EU \cite{EuropeanParliament2016}, the European convention of human rights \cite{EuropeanCourtofHumanRights2010} or the respective national law. \cite{EHG2015, DSG2000, ELGA2012}

Another issue that may  be stated here is that even if custom solutions for encryption do exist, they are not implemented to be turned on and off again easily.
This leads to the conclusion that it is not possible to perform image encryption without a required amount of previous knowledge and expertise with such solutions.

Our goal is to evaluate different possibilities, to make on-the-fly encryption for DSLR cameras possible.
To ensure comparability between the introduced possibilities it is inevitable to define measurable parameters.

As encryption requires computational resources, its performance is dependent on the platform it is used on.
Considering this fact it is essential to be aware of the limited hardware resources of DSLRs that can be used for encryption.
So we can state that the performance of the implemented algorithm may be measured by the speed of the encryption process (v\textsubscript{encryption}).
Furthermore, a threshold must be found that determines the minimal speed (v\textsubscript{min}) of the encryption process.

Additionally, it must be assured that the encrypted information may only be decrypted by authorized persons.
For this reason, the used encryption algorithm must be considered safe, according to the state of the art.

To ensure a specific degree of performance it is necessary that the evaluated solution does rely on as little proprietary soft- and hardware as possible.
An important information which is not known to us for now: whether or not it is better to perform encryption on DSLRs with software or hardware.
In the first place, this is a performance related topic, but it has big impact on portability.



Our final goal is to create a method which can evolve to a best practice, which gives the medical and journalist community the possibility to protect their data with the help of encryption.
A best practice solution should fulfil the following requirements in the best possible way.
\begin{enumerate}
  \item The speed of the encryption process must be greater than the defined threshold (v\textsubscript{encryption} $\geq$ v\textsubscript{min});
  \item The used encryption algorithm must be considered safe.
  \item The solution must not be limited to one DSLR manufacturer.
  \item Plausible deniability must be assured.
\end{enumerate}

\todo{explanation of fundamental terms and basic definitions}
PD

\subsection{Encryption}
As in this document we are going to write about solutions, which use encryption, we think it would be good to provide the reader some basic information about encryption.
According to the Oxford Dictionary encryption is the process of converting information or data into a code with the goal to prevent unauthorized access. \cite{OxforddictEncrypt}

In the field of cryptography there are two ways to encrypt something.
Either asymmetric or symmetric encryption algorithms can be used.
The main difference in the two methods are, that in case of the asymmetric encryption two keys are beeing used.
One for the encryption and a second one for the decryption.
On the other hand in case of the symmetric encryption there is onlye one key used both for the de- and encryption.
As we, during our project, mostly used symmetric-key schemes, we are going to focus on this, and we will not write about public-key schemes.

There are two major groups of symmetric encryption algorithms.
These are the block- and streamciphers.
Blockcipher algorithms devide the data into equal size blocks, and with the help of the encryption-key they perform the encryption on each blocks individually.
Streamciphers are a special kind of blockcipher, where the blocksize is one byte. \cite{menezes1996handbook}
Further classification of block- and streamciphers will not be included, as it would go beyond the scope of this paper.

\subsubsection{Advanced encryption Standard}
The currently used algorithm for encryption is the Advanced encryption standard (AES), which was defined in 2000, to replace the previous one, which were considered unsecure.

AES uses the Rijndael algorithm with some restrictions.
Rijndael was invented by Daemen et. al. \cite{daemen2013design}

As Rijndael is a blockcipher the round transformations will be applied on the datablocks in round number (N\textsubscript{r}) of times, which can either be plaintextblocks or cipherblocks.
The input for the algorithm is the key and the plaintextblock, and the output is the cipherblock, or the cipherblock with the key, and the output is in this case the plaintextblock. \cite{daemen2013design}

First the algorithm derives the round key from the userkey, which will be used during the inital key addition.
After this, the round tranformations will be applied N\textsubscript{r}-1 times, and finally during the final round the encryption considered done.
One round consits of four trandformations,
\begin{labeling}{AddRoundkey}
\item [SubBytes] This is the only non-linear transformation of the algorithm. Every byte will be mapped on an other with the help of a Substitution-Box (S-Box).
\item [ShiftRows] During this step every row of the state (which is a 2D-array representation of the block) will be shifted cycliically over different offsets.
\item [MixColumns] In this step every column will be multipied by the following polynome \begin{math} c(x) = 03 * x^3 + 01 * x^2 + 01 * x + 02 \mod x^4 + 1 \end{math}
\item [AddRoundkey] In this final step we apply bitwise XOR to the current block with the roundkey.
\end{labeling}
The decryption uses the inverse of the round transformation, which means they do the same, only in the other direction. \cite{daemen2013design}

\subsubsection{ChaCha20}
Without beeing too detaild, we are shortly going to introduce the ChaCha20 encryption algorithm, as we are going to use it later.

ChaCha20 is a derivate of the Salsa20 algorithm family. 
The Salsa20 algorithm is a stream cipher, so according to our previous deffinition by Menzenes et al. in \cite{menezes1996handbook} we are talking about a cipher where the blocksize is one byte.
However according to Bernstein, Salsa20 "generates the stream in 64-byte blocks". \cite{bernstein2008salsa20}

But without beeing cought up too long with the categorization of an algorithm lets jump to the description of how Salsa20 and ChaCha20 work.
Salsa20 uses a 256-bytes key, which will be expanded with a 64-bit unique message number to a \begin{math} 2^{70} \end{math}-bytes stream.
To encrypt \textit{b}-byte of plaintext it takes the first \textit{b}-bytes of the stream and xors it with the plaintext.
The rest of the stream will not be used.
The decryption works just like the encryption.
Salsa20 works only with 3 kind of operations on 32-bit words.
These are addition of two numbers modulo \begin{math} 2^{32} \end{math}, xoring two numbers and rotating a number by some constant bits.
These three operations can be run on every CPU very efficiently, without needing and dedicated hardware like in the case of AES. \cite{bernstein2008salsa20}

ChaCha20, as mentioned before is a derivate of the Salsa20-family.
There are three differences:
\begin{enumerate}
  \item Due to performance effects the order of the words within the output block are permutated.
  \item The initial matrix which is used during the encryption and decryption is built in a slightly different way.
    In the case of Salsa20 the user inputs are scattered within the matrix, wheres in ChaCha these reside in the last row of the matrix.
  \item "ChaCha sweeps through the rows in the same order in every round."
\end{enumerate}
\cite{bernstein2008chacha}

\todo{outline of the manuscript}


\newpage
\section{Related Work}
As it is likely when getting in touch with state of the art technology, the number of related scientific papers seems to be limited.
The most important research done on this field that could have been obtained is briefly described in this section, to give readers a short introduction on the existing literature. 
The most outstanding work related to the topic examined in this state of the art report is titled ``A VHDL Architecture for Auto Encrypting SD Cards'' and was published by the University of Gothenburg in November 2016 \cite{Davidsson2016}.
To summarize, the students working on this master's thesis designed an encrypted SD-card for journalists.

The approach was based on a hardware solution.
An SD-Card adapter was designed, that applies to the SD-card standard, in other words, the auto-encrypting SD had the size and shape of a usual SD card.
Inside this seemingly normal SD-card there was an encryption hardware module, based around a FPGA and a publicly available intellectual property core, which was used for encryption.

A speciality about this approach is that the design aims the SD-card to be used by journalists, who work in ``destabilized areas''.
By this the authors of the thesis mean countries, where a journalists takes big risks when taking photographs and trying to get these photographs out of the country.
This is the point, where plausible deniability takes effect: When a new photograph is saved, it first is encrypted and then hidden on the file system, so no traces of the photographs may be found and the journalists are safe.

The encryption of the data is realised with a ChaCha20 algorithm that is implemented in the used FPGA.
For the encryption a pair of public and private keys is created outside of the SD card.
The public key gets stored on the SD card afterwards.
The decryption is performed outside of the SD with the use of the private key.
It is important here to notice, that previewing the photographs is possible as long as the SD card is powered up. 

What is missing in the described approach is a hardware implementation.
All of the work that was done to achieve what was achieved in this project was carried out on a simulator.
Even though the writers of this thesis achieved all of their goals it is inevitable to thoroughly test this solution as a fully developed hardware platform to proof the applicability of the proposed solution.

An issue that has not been addressed completely in our opinion is the plausible deniability.
Even though the proposed solution ``hides previously created encrypted files from the camera'', it is not assured that this file hiding is sufficient towards forensic analysis.

Another approach to this issue, especially focused on plausible deniability was developed by Adam Skillen and Mohammad Mannan at the Concordia University in Montreal, Canada \cite{skillen2013implementing}.
This solution is basically an app (``Mobiflage'') that stores photographs on a deniable file system, which means hiding encrypted volumes within random data on the external storage of a mobile device.
The paper was published in 2013.

Google's Android operating system was used for the prototypic implementation of Mobiflage.
A precondition for the application of Mobiflage is the existence of an external memory (SD-card), as the proposed solution does not support internal memory.
Two separate volumes are created on the volumes of the SD-card:
\begin{enumerate}
  \item An userdata volume, used for settings and application data
  \item An auxillary volume, where the photos will be persisted
\end{enumerate}

Mobiflage achieves plausible deniability through plausible deniable encryption (PDE) this technique enables the output of different reasonable and innocuous plaintexts from a given ciphertext.
The original plaintext (or the image data) is only revealed if the correct key is entered.
This makes the decrypted data seem correct for unauthorized individuals trying to force the disclosure of the encrypted information.
As Skillen et. al states, there is a file system for Linux called ``Rubberhose'' which features PDE.
Mobiflage features two modes for saving images: 
\begin{enumerate}
  \item Standard Mode
  In this mode the so called ``decoy'' password is entered at boot time and non-sensitive data is displayed.
  The storage medium is mounted as Mobiflage isn't installed.
  \item PDE mode
  In the PDE mode the user enters the ``trust'' password at boot time and the hidden data may be accessed on the SD-card.
\end{enumerate}

The most important aspect here is that the source of the image is a smartphone or tablet and not a DSLR or any other kind of camera.
This fact reduces the time from the capture of the image to the secure persistence on the memory drastically.
From the other point of view it might not be sufficient enough for a journalist to take pictures with a smartphone, instead he relies on professional equipment like a DSLR to achieve the desired quality of work.

What is missing in this approach is the universality of the solution.
The clear advantage of the approach of Davidsson et. al \cite{Davidsson2016} is that the SD-card may be used in any device, regardless of DSLR or smartphone.

\newpage
\section{Method}
\newpage
\section{Results}
\newpage
\section{Discussion}
\newpage
\section{Conclusion}
\newpage

% Add a bibliography.
\bibliographystyle{ieeetr}

\bibliography{star-report}
\end{document}
